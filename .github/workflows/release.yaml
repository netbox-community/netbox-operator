---
name: Release

on:
  workflow_dispatch:
    inputs:
      version:
        description: 'Version that should be released, format: v0.0.0'
        required: true
        type: string
      tagMessage:
        description: 'Message that will be added to the version tag'
        required: true
        type: string

permissions:
  contents: write
  pull-requests: write

jobs:
  release:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@ff7abcd0c3c05ccf6adc123a8cd1fd4fb30fb493  # v5.0.0
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 0

      - name: Configure git
        run: |
          git config --global user.email "github-actions[bot]@users.noreply.github.com"
          git config --global user.name "github-actions[bot]"

      - name: Update kustomization.yaml
        run: |
          # Fail if tag already exists
          if [ -n "$(git tag --list "${{ inputs.version }}")" ]; then
            echo "Tag "${{ inputs.version }}" already exists. Exit."
            exit 1
          else
            echo "Tag "${{ inputs.version }}" does not exist. Continue."
          fi

          # Update image tag
          cd config/manager
          kustomize edit set image controller="netbox-operator:${{inputs.version}}"
          cd ../..

      - name: Generate release notes for changelog
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Get the previous tag to determine commit range
          PREVIOUS_TAG=$(git describe --tags --abbrev=0 HEAD^ 2>/dev/null || echo "")

          # Generate release notes using GitHub API without creating a release
          if [ -n "$PREVIOUS_TAG" ]; then
            RELEASE_NOTES=$(gh api repos/:owner/:repo/releases/generate-notes \
              -f tag_name="${{ inputs.version }}" \
              -f target_commitish="$(git rev-parse HEAD)" \
              -f previous_tag_name="$PREVIOUS_TAG" \
              --jq '.body')
          else
            # If no previous tag, generate notes from all commits
            RELEASE_NOTES=$(gh api repos/:owner/:repo/releases/generate-notes \
              -f tag_name="${{ inputs.version }}" \
              -f target_commitish="$(git rev-parse HEAD)" \
              --jq '.body')
          fi

          # Save release notes to a file for use in changelog
          echo "$RELEASE_NOTES" > /tmp/release_notes.md

      - name: Update CHANGELOG.md
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Update changelog with the generated notes
          ./scripts/update-changelog-from-release.sh "${{ inputs.version }}"

      - name: Commit and push changes
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Check if there are changes to commit
          if git diff --quiet; then
            echo "No changes to commit"
            exit 0
          fi

          # Create a new branch for the changes
          BRANCH_NAME="release-updates-${{ inputs.version }}"
          git checkout -b "$BRANCH_NAME"

          git add config/manager/kustomization.yaml CHANGELOG.md
          git commit -m "[skip ci] chore: bump version to ${{ inputs.version }} and update changelog"
          # Push the branch and create PR

          git push origin "$BRANCH_NAME"
          PR_URL=$(gh pr create \
            --title "chore: bump version to ${{ inputs.version }} and update changelog" \
            --body "Automated version bump and changelog update for release ${{ inputs.version }}" \
            --head "$BRANCH_NAME" \
            --base main)

          # Extract PR number from URL
          PR_NUMBER=$(echo "$PR_URL" | sed 's/.*\/pull\///')
          echo "Created PR #$PR_NUMBER: $PR_URL"

          # Merge the PR
          gh pr merge "$PR_NUMBER" --squash --delete-branch

      - name: Create GitHub Release
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Create release with auto-generated notes
          gh release create "${{ inputs.version }}" \
            --title "${{ inputs.version }}" \
            --notes "${{ inputs.tagMessage }}" \
            --generate-notes
